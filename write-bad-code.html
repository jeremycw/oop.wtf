<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Write Bad Code</title>
    <style>
      body {
        margin: 40px auto;
        max-width: 650px;
        line-height: 1.6;
        font-size: 17px;
        font-family: sans-serif;
        color: #2e2e2e;
        padding: 0 10px
      }
      h1,h2,h3 {
        line-height:1.2
      }
      a {
        color: #0366d6;
      }
      a:visited {
        color: #0366d6;
      }
      a:hover {
        text-decoration: none;
      }
      pre {
        background-color: #eeeeee;
        padding: 5px 10px;
        margin: 0px;
        overflow: scroll;
      }
    </style>
  </head>
  <body>
    <a href="/"><< Back</a>
<h1 id="write-bad-code">Write Bad Code</h1>
<p>2019-03-08</p>
<h2 id="or-how-i-learned-to-code-the-thing">or: How I Learned to Code the Thing</h2>
<p>My goal with this post is to maybe put a seed of doubt into how you perceive what is &#8216;good&#8217; code and what is &#8216;bad&#8217; code. First though, I&#8217;m going to break down what I feel someone means when they say &#8216;This is good code&#8217; thereby defining &#8216;bad&#8217; code as the opposite of that.</p>
<p>When I hear someone qualify code as &#8216;good&#8217; code it generally means that the code meets some checklist of principles that they have internalized over their career or education. These are definitely not the same for every programmer and can vary greatly for programmers who follow different programming paradigms like Object Oriented vs.&#160;Functional. Here are some examples that you&#8217;ve probably heard and possibly believe yourself:</p>
<ul>
<li>Don&#8217;t use global variables</li>
<li>Don&#8217;t use singletons</li>
<li>Composition over inheritance</li>
<li>Method has no more than 5 parameters</li>
<li>Functions should be pure</li>
<li>Law of Demeter</li>
<li>Single Responsibility Principle</li>
<li>DRY</li>
<li>Uses currently in vogue architecture</li>
</ul>
<p>The list could go on and on. Good code often dogmatically follows these rules and any piece of code that doesn&#8217;t is a hack or something that needs to be refactored later. Bad code, being the opposite of good code would be code that doesn&#8217;t follow these rules.</p>
<p>I feel this is because of our need to quantify things as engineers. We want a reproducible method of solving all problems, the One True Way so we come up with rules to follow that will always produce &#8216;good&#8217; code.</p>
<p>What&#8217;s the problem with this? The first issue is that you can no longer solve the problem in the most straight forward way. You&#8217;ve constructed a maze of restrictions to code around that will ultimately end up in more code being written. It will take longer to write this code as well since you need to think not only about solving the problem you set out to you have to solve it in a way that satisfies the numerous constraints you&#8217;ve imposed on yourself. This is tantamount to coding with one hand tied behind your back.</p>
<p>Next, as I said, you end up with more code. Not only more code but code that doesn&#8217;t solve your problem. It&#8217;s code that solves the fake problem you made for yourself. The more code like this that your project has the harder it becomes to understand what is happening. The signal to noise ratio can quickly deteriorate as more code is added to deal with problems created by code that was never needed in the first place. Some of the worst cases I&#8217;ve seen of this happen when trying to follow some architecture or introducing patterns into the code.</p>
<p>It&#8217;s also evident to me that these rules of &#8216;good&#8217; code are so ingrained in people that they can&#8217;t see past them. On a Hacker News <a href="http://iolivia.me/posts/24-hours-of-rust-game-dev/">post</a> a few days ago there was a classic &#8220;Look at this architecture in a toy example, it will solve all your problems&#8221;. In this case it was about Entity Component System. Jon Blow <a href="https://news.ycombinator.com/item?id=19307458">commented</a> pointing out that ECS is completely unnecessary and this could be better solved by writing code in the most obvious way. This <a href="https://news.ycombinator.com/item?id=19309151">reply</a> which I&#8217;ll quote here exemplifies the mental shackles &#8216;good&#8217; code puts on people:</p>
<blockquote>
<p>By the obvious way, I&#8217;m guessing you would just have a single type &#8216;entity&#8217; and put all entities in an array? While that may be obvious to you, it&#8217;s not obvious to a lot of programmers (myself included) who grew up learning about object orientation, abstractions and modeling behaviour on the real world. ECS&#8217;s for all their added complexity come with the breath of fresh air that is classical imperative programming where all the data is just available. There are scant few sources for learning this, Handmade Hero being a notable exception.</p>
</blockquote>
<p>People have been so indoctrinated into the cult of &#8216;good&#8217; code they can&#8217;t even fathom what straight forward code might be. They can&#8217;t think about programming without thinking about objects and modeling real world things. The only way they can break free from the shackles of &#8216;good&#8217; code is to swap their current set of rules for another. You don&#8217;t need an ECS to have access to the data you just need to not follow the rules which tell you to hide it in the first place. What&#8217;s the obvious way to code the solution? It&#8217;s not a trick, he just means write the code that does the thing you need done. Write the code that does the thing. Enties have nothing to do with solving the problem. I can guarantee you that Super Mario Bros.&#160;doesn&#8217;t have a concept of entities in the code.</p>
<p>Here&#8217;s some &#8216;bad&#8217; code:</p>
<pre><code>void jump() {
  mario.yvel = 10;
}</code></pre>
<p>I can tell there are alarm bells ringing in your head. &#8220;But what if something other that Mario needs to jump?&#8221;, &#8220;Is mario a global? What if I need more than one mario?&#8221;. These things don&#8217;t matter. This code solves the problem I&#8217;m trying to solve, Mario needs to jump. Not the ones I don&#8217;t have, multiple Marios and things other than Mario jumping. Don&#8217;t pre-emptively solve problems you don&#8217;t have, solve the ones you do. If I do need to have multiple marios then I can change the code later when that comes up, it&#8217;s really not that big a deal. Your bad code will probably be shorter and to the point.</p>
<p>Write bad code. Ha-code-a Matata, means no worries for the rest of your code. Forget all the rules and just write code to do the thing. Solve your actual problems not some problems that someone else has told you that you might run into in the future. Sometimes you&#8217;ll write a big ol switch statement because that&#8217;s the most obvious way to solve the problem. Embrace it, don&#8217;t waste your time thinking of a way to make it &#8216;nicer&#8217; or &#8216;elegant&#8217;. Write abstractions when you face real maintenance hardships, but write small abstractions you probably don&#8217;t need an &#8216;architecture&#8217;.</p>
<p>We write software to solve problems. If the code you are writing is not solving the problem you set out to solve but one imposed upon yourself, consider writing bad code. Maybe you&#8217;ll become the 10x developer everyone is amazed by.</p>
    <a href="/"><< Back</a>
  </body>
</html>
